#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potliftR,       sensorAnalog)
#pragma config(Sensor, in2,    potliftL,       sensorAnalog)
#pragma config(Sensor, dgtl1,  limitColor,     sensorTouch)
#pragma config(Sensor, dgtl2,  limitZone,      sensorTouch)
#pragma config(Sensor, dgtl3,  pushAuto,       sensorTouch)
#pragma config(Sensor, I2C_1,  encbaseL,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encbaseR,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           liftR,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           intakeR,       tmotorVex393, openLoop)
#pragma config(Motor,  port3,           baseRF,        tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port4,           baseRM,        tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           baseRB,        tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           baseLF,        tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           baseLM,        tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           baseLB,        tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           intakeL,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          liftL,         tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


////////////////////////////////////////////////////////
//
//  VARIABLES
//
////////////////////////////////////////////////////////

int threshold = 20; //joystick threshold

//Drive variables
float driveRatio = 0.99; //multiplier for drive motor power
float secondDriveRatio; //multiplier for driver half speed
bool rdriveRunning, ldriveRunning;  //true when speed > 60

//Lift variables
float liftRatio = 0.99; //multiplier for lift motor power
int constantLift = 15; //speed of lift motors needed to maintain constant height
int minRight = 400; //right pot value increases as lift goes up
int maxRight = 1915;
int minLeft = 500; //left pot value increases as lift goes up
int maxLeft = 2115;
int tapGap = 300; //potentiometer difference for TapLift
bool liftRunning;

//Intake variables
float intakeRatio;
bool intakeRunning, outtakeRunning;

////////////////////////////////////////////////////////
//
//  FUNCTIONS
//
////////////////////////////////////////////////////////

//////////////////////////
//  ResetI2C
//////////////////////////

void ResetI2C()
{
nMotorEncoder[baseRB] = 0;
nMotorEncoder[baseLB] = 0;
}

///////////////////////////
//  Drive
//  rspeed: speed at which to drive right side
//  lspeed: speed at which to drive left side
//////////////////////////

void Drive (int rspeed, int lspeed)
{
motor[baseLB] = lspeed;
motor[baseRB] = rspeed;
motor[baseRM] = rspeed;
motor[baseLM] = lspeed;
motor[baseLF] = lspeed;
motor[baseRF] = rspeed;
if(abs(rspeed) > 60)
rdriveRunning = true;
if(abs(lspeed) > 60)
ldriveRunning = true;
}

///////////////////////////
//  Intake
//  intakeSpeed: (+) is intake; (-) is outtake
//////////////////////////

void Intake(int intakeSpeed)
{
motor[intakeR] = intakeSpeed;
motor[intakeL] = intakeSpeed;
if (intakeSpeed > 0)
intakeRunning = true;
else if (intakeSpeed < 0)
outtakeRunning = true;
}

///////////////////////////
//  Lift
//  liftSpeed: speed at which to move the lift
//////////////////////////

void Lift(int liftSpeed)
{
 motor[liftR] = liftSpeed;
 motor[liftL] = liftSpeed;
}

///////////////////////////
//  Bring lift down
//////////////////////////

void LiftDown()
{
if (SensorValue[potliftL] > (minLeft + tapGap)) {
Lift((int)((300-SensorValue[potliftL])/50));
}
else {
Lift(-20);
}
liftRunning = true;
}

///////////////////////////
//  Set lift power to bring it to a set height
//  lifttarget: target lift potentiometer reading
//////////////////////////

void LiftTo(int lifttarget)
{
int tolerance = 10;
if (lifttarget == 0)
{
Lift(constantLift);
}
else if (SensorValue[potliftL] < (lifttarget - tolerance))
{
Lift(120);
}
else if (SensorValue[potliftL] > (lifttarget + tolerance))
{
LiftDown();
}
else
{
tolerance = 30;
Lift(constantLift);
}
liftRunning = true;
}

///////////////////////////
//  Drive with encoders and lift
//  rspeed: speed at which to drive right side
//  lspeed: speed at which to drive left side
//  rtarget: target encoder value for right side
//  ltarget: target encoder value for left side
//  lifttarget: target potentiometer value for lift (set to 0 if you don't want to move the lift)
//////////////////////////

void DriveE (int rspeed, int lspeed, int rtarget, int ltarget, int lifttarget)
{
ResetI2C();

if (abs(rtarget) > 0 && abs(ltarget) > 0)
{
while (abs(nMotorEncoder[baseRB]) < abs(rtarget) && abs(nMotorEncoder[baseLB]) < abs(ltarget))
{
Drive(rspeed, lspeed);
LiftTo(lifttarget);
}
}
else if (rtarget == 0 && abs(ltarget) > 0)
{
while (abs(nMotorEncoder[baseLB]) < abs(ltarget))
{
Drive(rspeed, lspeed);
LiftTo(lifttarget);
}
}
else if (abs(rtarget) > 0 && ltarget == 0)
{
while (abs(nMotorEncoder[baseRB]) < abs(rtarget))
{
Drive(rspeed, lspeed);
LiftTo(lifttarget);
}
}
while (lifttarget != 0 && (SensorValue[potliftL] < (lifttarget - 10) || SensorValue[potliftL] > (lifttarget + 10)))
{
Drive(0,0);
LiftTo(lifttarget);
}
ResetI2C();
}

///////////////////////////
//  Switch drive (switches L and R depending on boolean input)
//  rspeed: speed at which to drive right side
//  lspeed: speed at which to drive left side
//  rtarget: target encoder value for right side
//  ltarget: target encoder value for left side
//  normal: 1 if normal; 0 if switch side
//////////////////////////
void DriveS(int rspeed, int lspeed, int rtarget, int ltarget, int lifttarget, bool normal)
{
if (normal == 1)
DriveE(rspeed, lspeed, rtarget, ltarget, lifttarget);
else
DriveE(lspeed, rspeed, ltarget, rtarget, lifttarget);
}

////////////////////////////////////////////////////////
//
//  AUTONOMOUS
//
////////////////////////////////////////////////////////

///////////////////////////
//  Middle Zone Autonomous
//  startSide: 1 if we're red; 0 if we're blue
//////////////////////////

void MiddleZoneAutonomous(bool startSide)
{
//----Push first LB off barrier----//
while (SensorValue[potliftL] < (minLeft + tapGap)) {
Lift(125);
}
DriveE(90,90,400,400,(maxLeft-400));
Lift(constantLift);
Drive(0,0);
wait1Msec(400);
DriveE(-90,-90,400,400,0);

//----Push second LB off barrier----//
while(SensorValue[pushAuto] == 0){
Drive(0,0);
}
DriveE(100,100,800,800,0);
Drive(0,0);
wait1Msec(400);
Intake(-127);
wait1Msec(500);
Intake(0);
DriveE(-90,-90,600,600,minLeft+tapGap);
Drive(0,0);
}



///////////////////////////
//  Hanging Zone Autonomous
//  startSide: 1 if we're red; 0 if we're blue
//////////////////////////

void HangingZoneAutonomous(bool startSide)
{
//----Intake BuckyBalls----//
Intake(120);
DriveE(100,100,200,200,0);
DriveE(50,50,100,100,0);
DriveE(-50,-50,-50,-50,0);

//----Score BuckyBalls----//
DriveS(120,-60,500,-250,(minLeft+400),startSide);
DriveE(120,120,300,300,(minLeft+800));
Drive(0,0);
Intake(-127);
wait1Msec(2000);

//----Push Large Balls----//
DriveE(-100,-100,200,200,minLeft+tapGap);
DriveE(100,100,100,100,0);
DriveE(-100,-100,200,200,0);

}




////////////////////////////////////////////////////////
//
//  PROGRAMMING SKILLS
//
////////////////////////////////////////////////////////


///////////////////////////
//  Start Autonomous (deploy intake)
//////////////////////////

void StartAutonomous()
{
wait1Msec(10);
ResetI2C();
Intake(120);
wait1Msec(500);
Intake(0);
}

void ProgrammingSkills()
{
MiddleZoneAutonomous(1);
while(SensorValue[pushAuto] == 0){
Drive(0,0);
}
//third large ball
DriveE(120,120,1800,1800,(maxLeft-400));
DriveE(100,-100,400,400,0);
DriveE(90,90,500,500,0);
Drive(0,0);
wait1Msec(400);
DriveE(-90,-90,200,200,0);
DriveE(-100,0,600,0,0);
//fourth large ball
DriveE(100,100,1000,1000,0);
DriveE(100,-100,500,500,0);
DriveE(90,90,200,200,0);
Drive(0,0);
wait1Msec(400);
}
